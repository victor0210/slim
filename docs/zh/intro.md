# 介绍

## Slim是什么
**Slim** 是一个前端用于集中式简单状态管理框架。

### 状态管理
相信状态管理大家都已经不陌生了，不过在这里也再简单聊聊：

不管是框架开发（Vue，React）下的应用，还是无框架开发，都需要将我们各种状态更好的管理以便于状态不会变得混乱不可预测以至于整个应用难以维护。
所以状态管理的注意思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。根据这个思路，产生了很多的模式和库：Flux，Redux，Vuex 等

## Slim的特点

* **使用Proxy进行数据劫持使其拥有极强的状态更新限制**
* **友好的API**
* **简便的使用步骤**
* **更小的体积**
* **易于被集成到各个业务场景或框架**
* **内置事件中心，将全局事件一网打尽**

### 使用简单
只需要像下面一样注册`State`和`Reducer`即可使用，[更多详情](/zh/reducer.html)

```javascript
const state = {
  name: 'hello world1'
}

const reducers = {
  changeName: state => { state.name = 'hello everyone!' }
}

const store = Slim.createStore({state, reducers})

store.dispatch('changeName') 
```

### 强限制
在**Slim**中如果开启`strict`模式以后，状态修改限制将变得异常的严格，任何在**Reducer**（**Slim**中状态变化的管理区域）以外的状态修改都将不被允许。

### 小尺寸
整个**Slim**库的体积大小为 `5kb` 不到

### 轻量级
和名字一样，**Slim**是一个轻量级状态管理工具，用更少的操作去管理状态，将变化控制在更集中的地方，不管是小型项目的快速管理还是大型项目的复杂管理都可以使用**Slim**来完成。

### 更灵活
**Slim**提供了两种约束模式，`strict`，`loose`，可以根据不同的需求进行切换。

### 易于集成
**Slim**提供了[Plugin](/zh/plugin.html)机制, 这为slim集成到现有流行框架提供了非常方便的操作。

## Slim解决什么问题

Slim的产生就是为了解决以下三种状态管理中的常见问题：

**1. 状态管理引入时机不好确定**

当我们需要维护较少状态的时候往往会通过一些简单的全局变量方式就处理好了，但是实际工作情况下，业务发展往往是不会按照你的预期进行，状态随时都有变得更大的可能，等到状态变得庞大甚至已经难以维护的时候再引入状态管理框架似乎已经错过了最佳时期，重构大量的状态可不是一件轻松的事。
也正是业务发展不可预期，状态什么时候会变得庞大其实也是一个未知数，在项目初期直接引入一些状态管理框架似乎也不是一个非常明智的决定，还相反会降低开发效率和开发体验。

**2. 状态管理操作繁琐**

大型状态管理框架已经提供了一种既定的状态管理模型，往往会有一些中间层，不太好直接进行精简，所以往往会把一些很简单的操作变得非常复杂。而简单的状态管理框架虽然提供了简单的操作但又无法保证大型应用场景下的状态控制。

**3. 状态管理不够严格**

大多数状态管理库并不能完全做到数据控制，以下两种特定的操作下状态变化依然不可控，而它们正好又是极其容易导致状态不可预测的典型例子。

```javascript
state.arr[newIndex] = xxx
obj.newKey = xxx
```

Slim拥有非常强的状态控制，不管是小型应用还是大型应用，都保证了都可以保证状态操作的简便性和状态变化的可控性。并且因为简化了状态操作，在项目初期引入Slim也不会造成负面影响。


## Slim应用场景

只要你需要状态管理，你就可以用到Slim，虽然Slim是一个**简单状态管理框架**，但是在**超强的状态更新限制机制**的保护下，加入任何中间层都是非常容易和安全的。

## Slim的拓展

* [如何在Vue中使用Slim](/zh/vslim.html)
* 如何在React中使用Slim（后续支持）
